using FileGlitcher.Processors.ByteRules;
using System;

namespace FileGlitcher.Processors
{
  /// <summary>
  /// Possible actions to do
  /// with the random generated byte.
  /// </summary>
  public enum RandomProcessorAction
  {
    /// <summary>
    /// Overwrites the original byte
    /// with the glitched byte.
    /// </summary>
    Set,

    /// <summary>
    /// Adds the glitched byte to
    /// the original byte.
    /// </summary>
    Add,

    /// <summary>
    /// Subtracts the glitched byte
    /// from the original byte.
    /// </summary>
    Subtract
  }

  /// <summary>
  /// Processor that randomizes bytes of a file.
  /// </summary>
  public class RandomProcessor : ProcessorBase
  {
    #region Properties

    /// <summary>
    /// Seed to use for RNG.
    /// </summary>
    public string Seed;

    /// <summary>
    /// Minimum byte value.
    /// </summary>
    public byte MinByte;

    /// <summary>
    /// Maximum byte value.
    /// </summary>
    public byte MaxByte;

    /// <summary>
    /// Action to do with the random generated byte.
    /// </summary>
    public RandomProcessorAction Action;

    /// <summary>
    /// If true, wraps the byte, if
    /// it would over- or underflow by a
    /// <see cref="RandomProcessorAction.Add"/> or
    /// <see cref="RandomProcessorAction.Subtract"/> action.
    /// </summary>
    public bool WrapAround;

    #endregion Properties

    #region Construction

    /// <summary>
    /// Constructor.
    /// </summary>
    /// <param name="rule">Byte rule defining which bytes to select for glitching.</param>
    /// <param name="action">Action to do with the random generated byte.</param>
    /// <param name="wrapAround">If true, wraps the byte, if
    /// it would over- or underflow by a
    /// <see cref="RandomProcessorAction.Add"/> or
    /// <see cref="RandomProcessorAction.Subtract"/> action.</param>
    /// <param name="seed">Seed to use for RNG.</param>
    /// <param name="minByte">Minimum byte value.</param>
    /// <param name="maxByte">Maximum byte value.</param>
    public RandomProcessor(ByteRuleBase rule, RandomProcessorAction action, bool wrapAround = true, string seed = null, byte minByte = 0, byte maxByte = 255)
      : base(rule)
    {
      Action = action;
      WrapAround = wrapAround;
      Seed = seed;
      MinByte = minByte;
      MaxByte = maxByte;
    }

    #endregion Construction

    /// <summary>
    /// Applies this processor to
    /// the given <paramref name="bytes"/>.
    /// Randomizes a total of <see cref="ProcessorBase.NumBytesToGlitch"/>
    /// bytes by filling them with random numbers between
    /// <see cref="MinByte"/> and <see cref="MaxByte"/>.
    /// If no <see cref="Seed"/> is given, <see cref="DateTime.Now.Ticks"/>
    /// HashCode will be used as a seed.
    /// </summary>
    /// <param name="bytes">Bytes to glitch.</param>
    /// <returns>Glitched bytes.</returns>
    public override byte[] Apply(byte[] bytes)
    {
      // todo: create rule index pool

      Random rnd = string.IsNullOrEmpty(Seed) ? new Random(DateTime.Now.Ticks.GetHashCode()) : new Random(Seed.GetHashCode());

      while (_byteRule.NumBytesLeftToGlitch != 0)
      {
        uint byteIndex = _byteRule.GetNextByteIndex();
        byte generatedByte = (byte)rnd.Next(MinByte, MaxByte);

        // apply action
        switch (Action)
        {
          case RandomProcessorAction.Set:
            bytes[byteIndex] = generatedByte;
            break;
          case RandomProcessorAction.Add:
            byte addByte = 0;

            if (!WrapAround)
            {
              if (bytes[byteIndex] + generatedByte > 255)
                addByte = 255;
            }
            else
              addByte = (byte)(bytes[byteIndex] + generatedByte);
            bytes[byteIndex] = addByte;
            break;
          case RandomProcessorAction.Subtract:
            byte subtractByte = 0;

            if (!WrapAround)
            {
              if (bytes[byteIndex] - generatedByte < 0)
                subtractByte = 0;
            }
            else
              subtractByte = (byte)(bytes[byteIndex] - generatedByte);
            bytes[byteIndex] = subtractByte;
            break;
        }
      }

      return bytes;
    }
  }
}